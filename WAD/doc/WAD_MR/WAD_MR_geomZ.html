<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of WAD_MR_geomZ</title>
  <meta name="keywords" content="WAD_MR_geomZ">
  <meta name="description" content="------------------------------------------------------------------------">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html WAD_MR -->
<h1>WAD_MR_geomZ
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>------------------------------------------------------------------------</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function WAD_MR_geomZ( i_iSeries, sSeries, sParams, sLimits ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ------------------------------------------------------------------------
 WAD_MR is an MRI analysis module written for IQC.
 NVKF WAD IQC software is a framework for automatic analysis of DICOM objects.
 
 Copyright 2012-2013  Joost Kuijer / jpa.kuijer@vumc.nl
 
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 ------------------------------------------------------------------------</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, limits, limits_field_name )">WAD_resultsAppendFloat</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendString.html" class="code" title="function WAD_resultsAppendString( level, value, description )">WAD_resultsAppendString</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>	------------------------------------------------------------------------</li><li><a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>	------------------------------------------------------------------------</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)</a></li><li><a href="#_sub2" class="code">function centerpixel = find_center_row(linesum,pixelspacing)</a></li><li><a href="#_sub3" class="code">function centerpixel = find_center_column(linesum,pixelspacing)</a></li><li><a href="#_sub4" class="code">function zerocross_pix = find_zerocrossing_pix( x )</a></li><li><a href="#_sub5" class="code">function [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)</a></li><li><a href="#_sub6" class="code">function [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ------------------------------------------------------------------------</span>
0002 <span class="comment">% WAD_MR is an MRI analysis module written for IQC.</span>
0003 <span class="comment">% NVKF WAD IQC software is a framework for automatic analysis of DICOM objects.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Copyright 2012-2013  Joost Kuijer / jpa.kuijer@vumc.nl</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% This program is free software: you can redistribute it and/or modify</span>
0009 <span class="comment">% it under the terms of the GNU General Public License as published by</span>
0010 <span class="comment">% the Free Software Foundation, either version 3 of the License, or</span>
0011 <span class="comment">% (at your option) any later version.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% This program is distributed in the hope that it will be useful,</span>
0014 <span class="comment">% but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0015 <span class="comment">% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0016 <span class="comment">% GNU General Public License for more details.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% You should have received a copy of the GNU General Public License</span>
0019 <span class="comment">% along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0020 <span class="comment">% ------------------------------------------------------------------------</span>
0021 
0022 <a name="_sub0" href="#_subfunctions" class="code">function WAD_MR_geomZ( i_iSeries, sSeries, sParams, sLimits )</a>
0023 <span class="comment">% Evaluate length of phantom in head-feet direction on mid-saggital slice (the actual length is 148 mm)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Input: SAG series on ACR phantom, for best results tilt 2 - 5 degrees (edge pixel subsampling)</span>
0026 <span class="comment">%        Analysis is performed on first image in series</span>
0027 <span class="comment">%        Parameters: none</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% Output: written via WAD_resultsAppend*() interface</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% This module consists of the following seven steps:</span>
0032 <span class="comment">% 1. Calculation of the row APPROXIMATELY centered in the middle of the phantom (&quot;center row&quot;)</span>
0033 <span class="comment">%    1. the image intensities along each row are summed</span>
0034 <span class="comment">%    2. the gradient of summed intensities is calculated</span>
0035 <span class="comment">%    3. the &quot;upper row&quot; is the max after multiplying the gradient with a function to find a positive step</span>
0036 <span class="comment">%    4. the &quot;lower row&quot; is the min after multiplying the gradient with a function to fing a negative step</span>
0037 <span class="comment">%    The &quot;center row&quot; will be used for</span>
0038 <span class="comment">%    - help finding the &quot;center column&quot;</span>
0039 <span class="comment">%    - for finding the precise edges a given distance interval above and below the &quot;center row&quot;</span>
0040 <span class="comment">%      (to minimize the chance of detecting wrong edges)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% 2. Calculation of the column APPROXIMATELY centered in the middle of the phantom (&quot;center column&quot;)</span>
0043 <span class="comment">%    It is used that a vertical &quot;hole&quot; aligned in the middle is present in the lower half of the phantom.</span>
0044 <span class="comment">%    1. the image intensities below the &quot;center row&quot; along each column are summed</span>
0045 <span class="comment">%    2. the &quot;center column&quot; is the maximum after multiplying the summed</span>
0046 <span class="comment">%       intensities with a function to find a symmetric minimum.</span>
0047 <span class="comment">%    The &quot;center column&quot; will be used for horizontal cropping of the binary edge image.</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% 3. Edge detection in horizontal direction.</span>
0050 <span class="comment">%      All edges with a direction significantly different from vertical will be detected.</span>
0051 <span class="comment">%      The result is a binary image.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% 4. Cropping of the binary image in horizontal direction to the &quot;center column&quot; plus and minus 45 mm</span>
0054 <span class="comment">%      Cropping is done for two reasons:</span>
0055 <span class="comment">%      1. A more unambiguous assignment of distance between edges in case these edges are curved.</span>
0056 <span class="comment">%      2. In the upper left corner a second edge (few millimeter lower than &quot;real&quot; edge) might also be detected.</span>
0057 <span class="comment">%         This unwanted edge can be aligned (towards the right) with the real edge in case this real edge is curved,</span>
0058 <span class="comment">%         giving rise to an unwanted peak in the Radon matrix.</span>
0059 <span class="comment">%      The cropped region is visualized in the output by vertical blue lines.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% 5. Radon transform</span>
0062 <span class="comment">%      Lines (or aligned line segments) in the cropped binary image are found by means of a Radon transform.</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% 6. Detection of two lines (or aligned line segments)</span>
0065 <span class="comment">%      Hereafter, &quot;shift&quot; (either positive or negative) corresponds to the difference between</span>
0066 <span class="comment">%      the &quot;center row&quot; of the phantom and the center row of the image.</span>
0067 <span class="comment">%      1. Most pronounced straight line (or aligned line segments), for which</span>
0068 <span class="comment">%       - shortest distance between line and center pixel is between 65+shift and 85+shift mm</span>
0069 <span class="comment">%       - the point along the line closest to the center pixel is ABOVE the center row of the phantom.</span>
0070 <span class="comment">%      2. Most pronounced straight line (or aligned line segments), for which (&quot;shift&quot; has now opposite sign)</span>
0071 <span class="comment">%       - shortest distance between line and center pixel is between 65+shift and 85+shift mm</span>
0072 <span class="comment">%       - the point along the line closest to the center pixel is BELOW the center row of the phantom</span>
0073 <span class="comment">%      The lines (corresponding to edges in the original image) are visualized in the output by red lines.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% 7. Calculation of length of phantom.</span>
0076 <span class="comment">%      This length equals the sum of the two &quot;shortest distances&quot;.</span>
0077 <span class="comment">%      For parallel lines, this corresponds to the distance between the lines.</span>
0078 <span class="comment">%      It is always a distance corresponding to a multiple of one pixel, also for rotated and curved edges.</span>
0079 <span class="comment">%      (this is a property of the Radon transform)</span>
0080 <span class="comment">%      Each shortest distance (center pixel - edge) is visualized in the output by a red line.</span>
0081 <span class="comment">%</span>
0082 <span class="comment">% ------------------------------------------------------------------------</span>
0083 <span class="comment">% WAD MR</span>
0084 <span class="comment">% file: WAD_MR_geomZ</span>
0085 <span class="comment">% ------------------------------------------------------------------------</span>
0086 <span class="comment">% VUmc, Amsterdam, NL / Frank de Weerd &amp; Joost Kuijer / jpa.kuijer@vumc.nl</span>
0087 <span class="comment">% 2009-05-13 / JK</span>
0088 <span class="comment">% second version</span>
0089 <span class="comment">% ------------------------------------------------------------------------</span>
0090 <span class="comment">% JK - 090925 v2.1: modified the algorithm</span>
0091 <span class="comment">% - use gradient image instead of binary edge</span>
0092 <span class="comment">% - use zero-crossing of derivative to find position of maximum in Radon</span>
0093 <span class="comment">% transform. This allows (linear) interpolation.</span>
0094 <span class="comment">% ------------------------------------------------------------------------</span>
0095 <span class="comment">% JK - 20120807 v2.1: adapted to WAD framework</span>
0096 <span class="comment">% ------------------------------------------------------------------------</span>
0097 
0098 <span class="comment">% produce a figure on the screen or be quiet...</span>
0099 quiet = true;
0100 isInteractive = false;
0101 
0102 <span class="comment">% version info</span>
0103 my.name = <span class="string">'WAD_MR_geomZ'</span>;
0104 my.version = <span class="string">'2.1'</span>;
0105 my.date = <span class="string">'20120807'</span>;
0106 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [<span class="string">'Module '</span> my.name <span class="string">' Version '</span> my.version <span class="string">' ('</span> my.date <span class="string">')'</span>] );
0107 
0108 <span class="comment">%gen_object_display( sSeries );</span>
0109 <span class="comment">%gen_object_display( sParams );</span>
0110 
0111 
0112 <span class="comment">% select the image within the series</span>
0113 inum = 1; <span class="comment">% there should be only 1 image...</span>
0114 
0115 
0116 <span class="comment">% find the image</span>
0117 foundImage = false;
0118 <span class="keyword">for</span> ii = 1:length( sSeries.instance )
0119     <span class="keyword">if</span> ( sSeries.instance(ii).number == inum )
0120         ci = ii;
0121         foundImage = true;
0122         <span class="keyword">break</span>;
0123     <span class="keyword">end</span>
0124 <span class="keyword">end</span>
0125 <span class="keyword">if</span> ~foundImage
0126     <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Error: could not find image number '</span> num2str( inum ) <span class="string">' for geometry Z'</span>], 1 );
0127     <a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>( isInteractive, [<span class="string">'Cannot find configured image number '</span> num2str( inum ) <span class="string">' for geometry Z evaluation.'</span>], <span class="string">'Geometry Z'</span>, <span class="string">'on'</span> );
0128     <span class="keyword">return</span>;
0129 <span class="keyword">end</span>
0130 
0131 <span class="comment">% display waitbar in interactive mode</span>
0132 <span class="keyword">if</span> isInteractive, h = waitbar( 0, <span class="string">'Calculating geometry Z'</span> ); <span class="keyword">end</span>
0133 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Calculating geometry Z ...'</span>] );
0134 
0135 <span class="comment">% read the DICOM image</span>
0136 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   loading DICOM image file: '</span> sSeries.instance(ci).filename ] );
0137 <span class="keyword">try</span>
0138     dcmInfo = dicominfo( sSeries.instance(ci).filename );
0139 <span class="keyword">catch</span> err
0140     <a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>( my.name, [<span class="string">'ERROR reading DICOM info from file &quot;'</span> sSeries.instance(ci).filename <span class="string">'&quot;)'</span>], err );
0141     <span class="keyword">return</span>
0142 <span class="keyword">end</span>
0143 <span class="keyword">try</span>
0144     a = dicomread( dcmInfo );
0145 <span class="keyword">catch</span> err
0146     <a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>( my.name, [<span class="string">'ERROR reading pixel data from DICOM file &quot;'</span> sSeries.instance(ci).filename <span class="string">'&quot;)'</span>], err );
0147     <span class="keyword">return</span>
0148 <span class="keyword">end</span>
0149 
0150 
0151 <span class="comment">%warndlg('Testcase CT fantoom: removing bottom part of image');</span>
0152 <span class="comment">%a(400:end,:)=0;</span>
0153 
0154 <span class="comment">% check that pixel size is square</span>
0155 dcmPxSp = dcmInfo.PixelSpacing;
0156 <span class="keyword">if</span> dcmPxSp(1) ~= dcmPxSp(2)
0157     <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Error: pixel size not equal in row and column direction. Currently not supported.'</span>] );
0158     <a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>( isInteractive, <span class="string">'Pixel size not equal in row and column direction. Currently not supported.'</span>, <span class="string">'Geometry Z'</span>, <span class="string">'on'</span> );
0159     <span class="keyword">return</span>;
0160 <span class="keyword">end</span>
0161 pixelspacing = dcmPxSp(1);
0162 
0163 <span class="comment">% JK - interpolate pixels to reduce discretisation of length measurement</span>
0164 <span class="comment">%WAD_vbprint( [my.name ':  starting interpolation'] );</span>
0165 <span class="comment">%a = interp2(a,1,'cubic');</span>
0166 <span class="comment">%pixelspacing = pixelspacing / 2;</span>
0167 
0168 image_dimension = size(a);
0169 largest_dimension = max(image_dimension);
0170 
0171 <span class="comment">% 1. find the APPROXIMATE center row</span>
0172 sum_over_columns = zeros( 1, image_dimension(1) );
0173 <span class="keyword">for</span> i=1:image_dimension(1),
0174     sum_over_columns(i) = sum(a(i,:));
0175 <span class="keyword">end</span>
0176 approx_center_row_pix = <a href="#_sub2" class="code" title="subfunction centerpixel = find_center_row(linesum,pixelspacing)">find_center_row</a>(sum_over_columns,pixelspacing);   
0177 
0178 <span class="comment">% 2. find the APPROXIMATE center column</span>
0179 sum_over_rows = zeros( 1, image_dimension(2) );
0180 <span class="keyword">for</span> i=1:image_dimension(2),
0181       sum_over_rows(i) = sum(a(approx_center_row_pix:image_dimension(1),i));
0182 <span class="keyword">end</span>
0183 approx_center_column_pix = <a href="#_sub3" class="code" title="subfunction centerpixel = find_center_column(linesum,pixelspacing)">find_center_column</a>(sum_over_rows,pixelspacing);
0184 
0185 <span class="comment">%warndlg('Testcase: fix center row/col');</span>
0186 <span class="comment">%sim testcase: approx_center_row_pix = 256; approx_center_column_pix = 256;</span>
0187 <span class="comment">%CT GE testcase:</span>
0188 <span class="comment">%approx_center_row_pix = 221; approx_center_column_pix = 246;</span>
0189 
0190 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   estimated approximate centre at row '</span> num2str(approx_center_row_pix) <span class="string">' and col '</span> num2str(approx_center_column_pix)] );
0191 
0192 
0193 <span class="comment">% 3. Edge detection</span>
0194 <span class="comment">% JK - 090925: use gradient image instead of binary edge image</span>
0195 <span class="comment">% bw = edge(a,'Sobel','horizontal');  % 'Prewitt' gives similar results</span>
0196 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   calculating gradient image'</span>] );
0197 [gx,gy] = gradient( double(a) );
0198 bw = sqrt( gx.^2 + gy.^2 ); <span class="comment">% magnitude of gradient</span>
0199 <span class="comment">%figure; colormap(gray(256)); image(bw)</span>
0200 
0201 
0202 <span class="comment">% update waitbar in interactive mode</span>
0203 <span class="keyword">if</span> isInteractive, waitbar( 0.3, h ); <span class="keyword">end</span>
0204 
0205 
0206 <span class="comment">% 4. Make a cropped image</span>
0207 <span class="comment">%    Consider only the middle part (45 mm left to 45 mm right)</span>
0208 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   cropping image'</span>] );
0209 start = round(approx_center_column_pix - 25/pixelspacing);
0210 stop  = round(approx_center_column_pix + 45/pixelspacing);
0211 
0212 <span class="comment">% Make vertical blue lines to show which part is selected</span>
0213 x_blueline1 = [start,start];
0214 y_blueline1 = [1,image_dimension(1)];
0215 x_blueline2 = [stop,stop];
0216 y_blueline2 = [1,image_dimension(1)];
0217 
0218 bw2=bw;
0219 <span class="keyword">for</span> i=1:start,
0220     <span class="keyword">for</span> j=1:image_dimension(1),
0221         bw2(j,i)=0;
0222     <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 
0225 <span class="keyword">for</span> i=stop:image_dimension(2),
0226     <span class="keyword">for</span> j=1:image_dimension(1),
0227         bw2(j,i)=0;
0228     <span class="keyword">end</span>
0229 <span class="keyword">end</span>
0230 
0231 <span class="comment">% update waitbar in interactive mode</span>
0232 <span class="keyword">if</span> isInteractive, waitbar( 0.5, h ); <span class="keyword">end</span>
0233 
0234 <span class="comment">%figure; colormap(gray(256)); image(bw2)</span>
0235 
0236 <span class="comment">% 5. Radon transform</span>
0237 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   calculating Radon transform'</span>] );
0238 theta = 70:0.5:110;                  <span class="comment">% steps of 0.5 degrees are chosen (this is somewhat arbitrarily)</span>
0239 [R,xp] = radon(bw2,theta);
0240 
0241 <span class="comment">%figure; imshow(R,[]);</span>
0242 
0243 <span class="comment">% update waitbar in interactive mode</span>
0244 <span class="keyword">if</span> isInteractive, waitbar( 0.8, h ); <span class="keyword">end</span>
0245 
0246 <span class="comment">%figure; imagesc(theta, xp, R); colormap(hot);</span>
0247 <span class="comment">%xlabel('\theta (degrees)'); ylabel('x\prime');</span>
0248 <span class="comment">%title('R_{\theta} (x\prime)');</span>
0249 <span class="comment">%colorbar</span>
0250 
0251 <span class="comment">% 6. Find the peaks in the Radon matrix</span>
0252 <span class="comment">%    An edge in the upper half of the image corresponds to a peak in the lower</span>
0253 <span class="comment">%    half of the Radon matrix.</span>
0254 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   finding peaks in Radon space'</span>] );
0255 middle_xp_pix = find(xp==0);
0256 ApproxZshift_pix = image_dimension(1)/2 - approx_center_row_pix;    <span class="comment">% negative means a downshift</span>
0257 
0258 <span class="comment">% Find the peak corresponding to the upper edge</span>
0259 StartUpper_pix = middle_xp_pix + round(ApproxZshift_pix) + round(65/pixelspacing);
0260 StopUpper_pix  = middle_xp_pix + round(ApproxZshift_pix) + round(85/pixelspacing);
0261 [UpperDistance_pix, Theta_Upper_deg] = <a href="#_sub1" class="code" title="subfunction [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)">find_the_peak</a>(R,xp,theta,StartUpper_pix,StopUpper_pix);
0262 
0263 <span class="comment">% Find the peak corresponding to the lower edge</span>
0264 StartLower_pix = middle_xp_pix + round(ApproxZshift_pix) - round(85/pixelspacing);
0265 StopLower_pix  = middle_xp_pix + round(ApproxZshift_pix) - round(65/pixelspacing);
0266 [LowerDistance_pix, Theta_Lower_deg] = <a href="#_sub1" class="code" title="subfunction [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)">find_the_peak</a>(R,xp,theta,StartLower_pix,StopLower_pix);
0267 
0268 <span class="comment">% 7. Calculate the size of the phantom along its longitudinal axis</span>
0269 Zsize_pix = UpperDistance_pix - LowerDistance_pix;
0270 
0271 lengthZ_mm = Zsize_pix * pixelspacing;
0272 rotationSAG_deg = 0.5 .* (Theta_Upper_deg + Theta_Lower_deg) - 90;
0273 
0274 <a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, limits, limits_field_name )">WAD_resultsAppendFloat</a>( 1, lengthZ_mm, <span class="string">'Lengte'</span>, <span class="string">'mm'</span>, <span class="string">'Geometrie Z'</span>, sLimits, <span class="string">'lengthZ_mm'</span> );
0275 <a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, limits, limits_field_name )">WAD_resultsAppendFloat</a>( 1, rotationSAG_deg, <span class="string">'Rotatie'</span>, <span class="string">'graden'</span>, <span class="string">'Geometrie Z'</span>, sLimits, <span class="string">'rotationSAG_deg'</span> );
0276 
0277 <span class="comment">%handles.results.lengthZ_mm</span>
0278 
0279 <span class="comment">% close waitbar in interactive mode</span>
0280 <span class="keyword">if</span> isInteractive, close( h ), <span class="keyword">end</span>
0281 
0282 
0283 <span class="comment">% In the matlab help, it can be found that the center pixel of image I in the Radon transformation is defined to be floor((size(I)+1)/2)</span>
0284 CenterPixel = floor((size(a)+1)/2);
0285 
0286 [x_edge_upper, y_edge_upper] = <a href="#_sub5" class="code" title="subfunction [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)">draw_the_edge</a>(CenterPixel,largest_dimension,UpperDistance_pix,Theta_Upper_deg);
0287 [x_edge_lower, y_edge_lower] = <a href="#_sub5" class="code" title="subfunction [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)">draw_the_edge</a>(CenterPixel,largest_dimension,LowerDistance_pix,Theta_Lower_deg);
0288 [x_distance_upper, y_distance_upper] = <a href="#_sub6" class="code" title="subfunction [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)">draw_the_distance</a>(CenterPixel,UpperDistance_pix,Theta_Upper_deg);
0289 [x_distance_lower, y_distance_lower] = <a href="#_sub6" class="code" title="subfunction [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)">draw_the_distance</a>(CenterPixel,LowerDistance_pix,Theta_Lower_deg);
0290 
0291 <span class="comment">% Draw all lines in the images</span>
0292 <span class="comment">% create figure</span>
0293 <span class="keyword">if</span> quiet 
0294     fig_visible = <span class="string">'off'</span>;
0295 <span class="keyword">else</span>
0296     fig_visible = <span class="string">'on'</span>;
0297 <span class="keyword">end</span>
0298 
0299 <span class="comment">% create figure</span>
0300 hFig1 = figure( <span class="string">'Visible'</span>, fig_visible, <span class="string">'MenuBar'</span>, <span class="string">'none'</span>, <span class="string">'Name'</span>, <span class="string">'Geometry Z'</span> );
0301 colormap( gray(256) );
0302 imagesc( a );
0303 axis image
0304 axis square
0305 axis off
0306 title( [ <span class="string">'series '</span> num2str(sSeries.number) <span class="string">' - image '</span> num2str(sSeries.instance(ci).number)], <span class="string">'Interpreter'</span>, <span class="string">'none'</span> );
0307 
0308 <span class="comment">%figure; colormap(gray(256)); imagesc(a);</span>
0309 
0310 hold on
0311 
0312 plot(x_edge_upper,y_edge_upper,<span class="string">'r-'</span>);
0313 plot(x_distance_upper,y_distance_upper,<span class="string">'r-'</span>);
0314 plot(x_edge_lower,y_edge_lower,<span class="string">'r-'</span>);
0315 plot(x_distance_lower,y_distance_lower,<span class="string">'r-'</span>);
0316 plot(x_blueline1,y_blueline1,<span class="string">'b-'</span>);
0317 plot(x_blueline2,y_blueline2,<span class="string">'b-'</span>);
0318 
0319 hold off
0320 
0321 
0322 <span class="comment">% Write figure to level 2</span>
0323 <a href="../WAD/WAD_resultsAppendString.html" class="code" title="function WAD_resultsAppendString( level, value, description )">WAD_resultsAppendString</a>( 2, [<span class="string">'Analysis on series: '</span> num2str(sSeries.number) <span class="string">' / image: '</span> num2str(inum) ], <span class="string">'Geometrie Z'</span> )
0324 <a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>( 2, hFig1, <span class="string">'geomZ_fitted'</span>, <span class="string">'Geometrie Z: randdetectie'</span> );
0325 <span class="keyword">if</span> quiet
0326     <span class="comment">% delete non-visible image</span>
0327     delete( hFig1 );
0328 <span class="keyword">end</span>
0329 
0330 
0331 <span class="comment">% create figure</span>
0332 hFig2 = figure( <span class="string">'Visible'</span>, fig_visible, <span class="string">'MenuBar'</span>, <span class="string">'none'</span>, <span class="string">'Name'</span>, <span class="string">'SNR / Ghosting'</span> );
0333 colormap( gray(256) );
0334 image( bw )
0335 axis image
0336 axis square
0337 axis off
0338 title( [ <span class="string">'series '</span> num2str(sSeries.number) <span class="string">' - image '</span> num2str(sSeries.instance(ci).number)], <span class="string">'Interpreter'</span>, <span class="string">'none'</span> );
0339 <span class="comment">%figure; colormap(gray(2)); image(bw)</span>
0340 
0341 hold on
0342 
0343 plot(x_edge_upper,y_edge_upper,<span class="string">'r-'</span>);
0344 plot(x_distance_upper,y_distance_upper,<span class="string">'r-'</span>);
0345 plot(x_edge_lower,y_edge_lower,<span class="string">'r-'</span>);
0346 plot(x_distance_lower,y_distance_lower,<span class="string">'r-'</span>);
0347 plot(x_blueline1,y_blueline1,<span class="string">'b-'</span>);
0348 plot(x_blueline2,y_blueline2,<span class="string">'b-'</span>);
0349 
0350 hold off;
0351 
0352 <span class="comment">% Write figure to level 2</span>
0353 <a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>( 2, hFig2, <span class="string">'geomZ_thresholded'</span>, <span class="string">'Geometrie Z: randdetectie (edge image)'</span> );
0354 <span class="keyword">if</span> quiet
0355     <span class="comment">% delete non-visible image</span>
0356     delete( hFig2 );
0357 <span class="keyword">end</span>
0358 
0359 
0360 
0361 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0362 <a name="_sub1" href="#_subfunctions" class="code">function [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)</a>
0363 <span class="comment">% JK - 090925: use zero-crossing of derivative instead of maximum.</span>
0364 <span class="comment">%figure; imshow(R(start_pix:stop_pix,:),[]);</span>
0365 
0366 <span class="comment">%[MaxPerTheta_vector LocationMaxPerTheta_vector] = max(R(start_pix:stop_pix,:));</span>
0367 [GlobalMax Theta_pix] = max(max(R(start_pix:stop_pix,:)));
0368 
0369 Theta_deg = theta(Theta_pix);
0370 <span class="comment">%dummy = LocationMaxPerTheta_vector(Theta_pix);</span>
0371 <span class="comment">%LocationMax_pix = dummy + start_pix - 1;</span>
0372 
0373 <span class="comment">% JK - 090925: take the pixels at the angle where the maximum is located</span>
0374 lineAtTheta = R(start_pix:stop_pix,Theta_pix);
0375 <span class="comment">%figure; plot(lineAtTheta);</span>
0376 <span class="comment">%figure; plot(gradient(lineAtTheta));</span>
0377 
0378 <span class="comment">% find the position of the maximum</span>
0379 zerocross_pix = <a href="#_sub4" class="code" title="subfunction zerocross_pix = find_zerocrossing_pix( x )">find_zerocrossing_pix</a>( gradient(lineAtTheta) );
0380 LocationMax_pix = zerocross_pix + start_pix - 1;
0381 
0382 <span class="comment">%distance_pix = xp(LocationMax_pix);</span>
0383 distance_pix = interp1( xp, LocationMax_pix);
0384 
0385 
0386 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0387 <a name="_sub2" href="#_subfunctions" class="code">function centerpixel = find_center_row(linesum,pixelspacing)</a>
0388 
0389 number_of_rows = length(linesum);
0390 
0391 fx = gradient(linesum);
0392 
0393 <span class="comment">%figure; plot(linesum);</span>
0394 <span class="comment">%figure; plot(fx);</span>
0395 
0396 <span class="comment">% find smallest element larger than zero</span>
0397 n=0;
0398 <span class="keyword">for</span> i=1:number_of_rows,
0399    <span class="keyword">if</span>(linesum(i) &gt; 0)
0400       n = n + 1;
0401       <span class="keyword">if</span>( n == 1) 
0402           smallest = linesum(i);
0403       <span class="keyword">elseif</span> (linesum(i) &lt; smallest)
0404              smallest = linesum(i);    
0405       <span class="keyword">end</span>    
0406    <span class="keyword">end</span>    
0407 <span class="keyword">end</span>
0408 
0409 <span class="comment">% make zero elements equal to smallest</span>
0410 <span class="keyword">for</span> i=1:number_of_rows,
0411    <span class="keyword">if</span> (linesum(i)==0)
0412        linesum(i)= smallest;
0413    <span class="keyword">end</span>    
0414 <span class="keyword">end</span>
0415 
0416 <span class="comment">% laat een mask van plus min 10 mm lopen</span>
0417 bandwidth = round(10/pixelspacing);
0418 
0419 test_value_left  = zeros( 1, number_of_rows );
0420 test_value_right = zeros( 1, number_of_rows );
0421 <span class="keyword">for</span> i = 1 : number_of_rows
0422    test_value_left(i) = 0;
0423    test_value_right(i) = 0;
0424    <span class="keyword">for</span> j= 1:bandwidth,   
0425      <span class="keyword">if</span> (i+j &gt; number_of_rows)
0426          value_right = smallest;
0427      <span class="keyword">else</span>
0428          value_right = linesum(i+j);
0429      <span class="keyword">end</span>  
0430      <span class="keyword">if</span> (i-j &lt; 1)
0431          value_left = smallest;
0432      <span class="keyword">else</span>    
0433          value_left = linesum(i-j);
0434      <span class="keyword">end</span>    
0435      ratio_left = value_right / value_left;
0436      ratio_right = value_left / value_right;     
0437      test_value_left(i) = test_value_left(i) + ratio_left;
0438      test_value_right(i) = test_value_right(i) + ratio_right;
0439    <span class="keyword">end</span>   
0440 <span class="keyword">end</span>
0441 
0442 linesum_left  = zeros( 1, number_of_rows );
0443 linesum_right = zeros( 1, number_of_rows );
0444 <span class="keyword">for</span> i=1:number_of_rows;
0445    linesum_left(i) = fx(i)*test_value_left(i);
0446    linesum_right(i) = fx(i)*test_value_right(i);
0447 <span class="keyword">end</span>
0448 
0449 <span class="comment">% skip some pixels near edge of image...</span>
0450 skip_pix = 10;
0451 linesum_left(1:skip_pix) = 0;
0452 linesum_left(number_of_rows-skip_pix:number_of_rows) = 0;
0453 linesum_right(1:skip_pix) = 0;
0454 linesum_right(number_of_rows-skip_pix:number_of_rows) = 0;
0455 
0456 <span class="comment">%figure; plot(test_value_left);</span>
0457 <span class="comment">%figure; plot(test_value_right);</span>
0458 <span class="comment">%figure; plot(linesum_left);</span>
0459 <span class="comment">%figure; plot(linesum_right);</span>
0460 
0461 <span class="comment">% find the upper edge</span>
0462 [maximum loc_max] = max(linesum_left);
0463 
0464 <span class="comment">% find the lower edge</span>
0465 [minimum loc_min] = min(linesum_right);
0466 
0467 centerpixel = round((loc_min + loc_max)/2);
0468 
0469 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0470 <a name="_sub3" href="#_subfunctions" class="code">function centerpixel = find_center_column(linesum,pixelspacing)</a>
0471 
0472 number_of_columns = length(linesum);
0473 
0474 <span class="comment">%figure; plot(linesum);</span>
0475 
0476 <span class="comment">% find smallest element larger than zero</span>
0477 n=0;
0478 <span class="keyword">for</span> i=1:number_of_columns,
0479    <span class="keyword">if</span>(linesum(i) &gt; 0)
0480       n = n + 1;
0481       <span class="keyword">if</span>( n == 1) 
0482           smallest = linesum(i);
0483       <span class="keyword">elseif</span> (linesum(i) &lt; smallest)
0484              smallest = linesum(i);    
0485       <span class="keyword">end</span>    
0486    <span class="keyword">end</span>    
0487 <span class="keyword">end</span>
0488 
0489 <span class="comment">% make zero elements equal to smallest</span>
0490 <span class="keyword">for</span> i=1:number_of_columns,
0491    <span class="keyword">if</span> (linesum(i)==0)
0492        linesum(i)= smallest;
0493    <span class="keyword">end</span>    
0494 <span class="keyword">end</span>
0495 
0496 <span class="comment">% laat een mask van plus min 30 mm lopen</span>
0497 bandbreedte = round(30/pixelspacing);
0498 
0499 test_waarde = zeros( 1, bandbreedte );
0500 <span class="keyword">for</span> i = bandbreedte + 1 : number_of_columns - bandbreedte - 1,
0501    test_waarde(i) = 0;
0502    <span class="keyword">for</span> j= 1:bandbreedte,   
0503      som = ((linesum(i-j) + linesum(i+j))/2) - linesum(i);
0504      ratio = linesum(i-j) / linesum(i+j);
0505      <span class="keyword">if</span> (ratio &gt; 1)
0506          ratio = 1/ratio;
0507      <span class="keyword">end</span>    
0508      som = som * ratio;
0509      test_waarde(i) = test_waarde(i) + som;
0510    <span class="keyword">end</span>
0511 <span class="keyword">end</span>
0512 
0513 <span class="keyword">for</span> i = number_of_columns - bandbreedte : number_of_columns,
0514    test_waarde(i) = 0;
0515 <span class="keyword">end</span>
0516        
0517 <span class="comment">%figure; plot(test_waarde);</span>
0518 
0519 <span class="comment">% find the center</span>
0520 [maximum loc_max] = max(test_waarde);
0521 
0522 centerpixel = loc_max;
0523 
0524 
0525 
0526 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0527 <span class="comment">% find zero-crossing in a 1D array, supposed to be the 2nd derivative of</span>
0528 <span class="comment">% the image intensity (in the Radon transform)</span>
0529 <span class="comment">% Return value is 0 when crossing is not found.</span>
0530 <a name="_sub4" href="#_subfunctions" class="code">function zerocross_pix = find_zerocrossing_pix( x )</a>
0531 <span class="comment">% search the zero crossing only between the maximum and the minimum</span>
0532 [~, max_i] = max( x );
0533 [~, min_i] = min( x ); <span class="comment">% min should have higher index than max</span>
0534 
0535 <span class="comment">% check if we should be able to find a proper zero crossing</span>
0536 <span class="keyword">if</span> ( x(max_i) &lt; 0 ) || ( x(min_i) &gt; 0 )
0537     fprintf( 2, <span class="string">'ERROR in SQ_MR_geomZ: cannot find edge. No zero-crossing of 2nd derivative.'</span> );
0538     zerocross_pix = 0;
0539     <span class="keyword">return</span>
0540 <span class="keyword">end</span>
0541 <span class="comment">% find the index where the sign has changed</span>
0542 <span class="keyword">for</span> ii = max_i:min_i
0543     <span class="keyword">if</span> x(ii) &lt; 0, <span class="keyword">break</span>, <span class="keyword">end</span>
0544 <span class="keyword">end</span>
0545 <span class="comment">% interpolate between pixels</span>
0546 zerocross_pix = (ii-1) + x(ii-1) ./ ( x(ii-1) - x(ii) );
0547 
0548 
0549 
0550 
0551 
0552 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0553 <span class="comment">% Turn the found edge into a red line</span>
0554 <a name="_sub5" href="#_subfunctions" class="code">function [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)</a>
0555 
0556 x(1) = CenterPixel(2) - largest_dimension .* sin(2*pi*Theta_deg/360);
0557 x(2) = CenterPixel(2) + largest_dimension .* sin(2*pi*Theta_deg/360);
0558 y(1) = CenterPixel(1) - largest_dimension .* cos(2*pi*Theta_deg/360);
0559 y(2) = CenterPixel(1) + largest_dimension .* cos(2*pi*Theta_deg/360);
0560 
0561 x = x + Distance_pix .* cos(2*pi*Theta_deg/360);
0562 y = y - Distance_pix .* sin(2*pi*Theta_deg/360);
0563 
0564 
0565 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0566 <span class="comment">% Make a distance line</span>
0567 <a name="_sub6" href="#_subfunctions" class="code">function [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)</a>
0568 
0569 x(1)= CenterPixel(2);
0570 x(2)= CenterPixel(2) + Distance_pix .* cos(2*pi*Theta_deg/360);
0571 y(1)= CenterPixel(1);
0572 y(2)= CenterPixel(1) - Distance_pix .* sin(2*pi*Theta_deg/360);</pre></div>
<hr><address>Generated on Wed 23-Oct-2013 14:08:22 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>